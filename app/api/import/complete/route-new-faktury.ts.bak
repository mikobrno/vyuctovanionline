// Nová verze importu faktur - jednoduše čte sloupec 0 = název, sloupec 1 = jednotka
export {} // Make this file a module

      // 3. IMPORT FAKTUR
      await send({ type: 'progress', percentage: 40, step: 'Importuji faktury a náklady...' })
      
      const invoicesSheetName = workbook.SheetNames.find(name => 
        name.toLowerCase().includes('faktur') || name.toLowerCase().includes('invoice')
      )

      if (invoicesSheetName) {
        const invoicesSheet = workbook.Sheets[invoicesSheetName]
        const rawData = utils.sheet_to_json<unknown[]>(invoicesSheet, { header: 1, defval: '' })
        
        await log(`[Faktury] Zpracovávám list "${invoicesSheetName}", celkem ${rawData.length} řádků`)
        
        // Jednoduše začneme od řádku 3 (index 2) a čteme až do konce
        const dataStartRow = 3 // Excel řádek 4 = index 3
        
        await log(`[Faktury] Data začínají na řádku ${dataStartRow + 1}`)
        
        // Cache services
        const dbServices = await prisma.service.findMany({ where: { buildingId: building.id } })
        const serviceKey = (value: string) => normalizeHeaderCell(value || '')
        const serviceMap = new Map<string, Service>()
        dbServices.forEach(s => serviceMap.set(serviceKey(s.name), s))

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const costsToCreate: any[] = []

        for (let i = dataStartRow; i < rawData.length; i++) {
          const row = rawData[i] as unknown[]
          if (!row || row.length === 0) continue
          
          const serviceName = String(row[0] ?? '').trim()
          const unitVal = String(row[1] ?? '').trim() // Jednotka je hned vedle názvu
          
          // Částka může být ve sloupci 2 nebo 3
          let amount = 0
          for (let col = 2; col < Math.min(row.length, 6); col++) {
            const val = parseFloat(String(row[col] ?? '').replace(/\s/g, '').replace(',', '.'))
            if (Number.isFinite(val) && val > 0 && val > 100) { // Částka větší než 100 Kč
              amount = val
              break
            }
          }

          if (!serviceName || serviceName.length < 2) continue
          if (!Number.isFinite(amount) || amount === 0) continue

          const cachedServiceKey = serviceKey(serviceName)
          let service = serviceMap.get(cachedServiceKey)

          const inferredMethod = detectCalculationMethodFromCells({
            methodCell: null,
            unitCell: unitVal,
            serviceName
          })
          const calculationMethod: CalculationMethod = inferredMethod ?? 'OWNERSHIP_SHARE'
          await log(`[Faktury] ${serviceName} → ${calculationMethod} (jednotka="${unitVal || '-'}")`)

          const serviceNormalized = normalizeHeaderCell(serviceName)
          const u = normalizeHeaderCell(unitVal)
          
          const src = (() => {
            if (calculationMethod === 'NO_BILLING') {
              return { dataSourceType: 'NONE', unitAttributeName: null, measurementUnit: null, dataSourceName: null }
            }

            if (calculationMethod === 'METER_READING') {
              const meterHints = `${u} ${serviceNormalized}`.trim()
              let dsName = 'Měřidla'
              let measurementUnit = 'jednotek'

              if (
                meterHints.includes('vodomer sv') ||
                meterHints.includes('sv voda') ||
                meterHints.includes('studen') ||
                meterHints.includes('pitn') ||
                meterHints.includes('vodne')
              ) {
                dsName = 'Vodoměry SV'
                measurementUnit = 'm³'
              } else if (
                meterHints.includes('vodomer tuv') ||
                meterHints.includes('tuv') ||
                meterHints.includes('tepla voda') ||
                meterHints.includes('ohrev') ||
                meterHints.includes('bojler')
              ) {
                dsName = 'Vodoměry TUV'
                measurementUnit = 'm³'
              } else if (
                meterHints.includes('teplo') ||
                meterHints.includes('vytap') ||
                meterHints.includes('radiator') ||
                meterHints.includes('patni') ||
                meterHints.includes('plyn') ||
                meterHints.includes('externi') ||
                meterHints.includes('kalor')
              ) {
                dsName = 'Teplo'
                measurementUnit = 'kWh'
              } else if (meterHints.includes('elektr')) {
                dsName = 'Elektroměry'
                measurementUnit = 'kWh'
              }

              return { dataSourceType: 'METER_DATA', unitAttributeName: null, measurementUnit, dataSourceName: dsName }
            }

            if (calculationMethod === 'AREA') return { dataSourceType: 'UNIT_ATTRIBUTE', unitAttributeName: 'CELKOVA_VYMERA', measurementUnit: 'm²', dataSourceName: null }
            if (calculationMethod === 'PERSON_MONTHS') return { dataSourceType: 'PERSON_MONTHS', unitAttributeName: null, measurementUnit: 'osobo-měsíc', dataSourceName: null }
            if (calculationMethod === 'FIXED_PER_UNIT') return { dataSourceType: 'UNIT_COUNT', unitAttributeName: null, measurementUnit: 'ks', dataSourceName: null }
            if (calculationMethod === 'EQUAL_SPLIT') return { dataSourceType: 'UNIT_COUNT', unitAttributeName: null, measurementUnit: 'ks', dataSourceName: null }
            if (calculationMethod === 'OWNERSHIP_SHARE') return { dataSourceType: 'UNIT_ATTRIBUTE', unitAttributeName: 'VLASTNICKY_PODIL', measurementUnit: '%', dataSourceName: null }

            return { dataSourceType: null, unitAttributeName: null, measurementUnit: null, dataSourceName: null }
          })()

          if (!service) {
            const baseCode = serviceName.substring(0, 10).toUpperCase().replace(/\s+/g, '_').replace(/[^A-Z0-9_]/g, '') || 'SERVICE'
            let created: Service | null = null
            for (let attempt = 0; attempt < 15 && !created; attempt++) {
              const candidate = attempt === 0 ? baseCode : `${baseCode}_${attempt}`
              try {
                created = await prisma.service.create({
                  data: {
                    buildingId: building.id, name: serviceName, code: candidate, methodology: calculationMethod as CalculationMethod,
                    dataSourceType: (src.dataSourceType as DataSourceType) ?? undefined, 
                    dataSourceName: src.dataSourceName ?? undefined,
                    unitAttributeName: src.unitAttributeName ?? undefined,
                    measurementUnit: src.measurementUnit ?? undefined, isActive: true, order: summary.services.total
                  }
                })
                service = created
                serviceMap.set(cachedServiceKey, service)
              } catch (e) { if (e instanceof Error && e.message.includes('Unique constraint failed')) continue; throw e; }
            }
            if (!service) throw new Error(`Nepodařilo se vytvořit službu '${serviceName}'`)
            summary.services.created++
          } else {
            // Update existing service methodology to match Excel
            service = await prisma.service.update({
              where: { id: service.id },
              data: { 
                methodology: calculationMethod as CalculationMethod,
                dataSourceType: (src.dataSourceType as DataSourceType) ?? undefined, 
                dataSourceName: src.dataSourceName ?? undefined,
                unitAttributeName: src.unitAttributeName ?? undefined,
                measurementUnit: src.measurementUnit ?? undefined
              }
            })
            serviceMap.set(cachedServiceKey, service)
            summary.services.existing++
          }
          summary.services.total++

          costsToCreate.push({
            buildingId: building.id, 
            serviceId: service.id, 
            amount, 
            description: `Import z Excelu - ${serviceName}`,
            invoiceDate: new Date(`${billingPeriod}-12-31`), 
            period: parseInt(billingPeriod)
          })
        }

        if (costsToCreate.length > 0) {
          await prisma.cost.createMany({ data: costsToCreate })
          summary.costs.created += costsToCreate.length
          summary.costs.total += costsToCreate.length
          await log(`[Faktury] Vytvořeno ${costsToCreate.length} nákladů.`)
        }
      }
